---
const { title, tagline } = Astro.props;
---
<section class="topo-hero">
  <canvas id="topo-canvas" aria-hidden="true"></canvas>
  <div class="overlay">
    <div class="grid" aria-hidden="true"></div>
    <div class="frame" aria-hidden="true"></div>
    <div class="hud" aria-hidden="true">
      <span id="coord" class="coord mono">0,0</span>
      <span class="compass n mono">N</span>
      <span class="compass e mono">E</span>
      <span class="compass s mono">S</span>
      <span class="compass w mono">W</span>
    </div>
  </div>
  <div class="hero-text">
    <h1>{title}</h1>
    <p class="subhead mono">{tagline}</p>
  </div>
  <style>
    .topo-hero {
      position: relative;
      width: 100%;
      aspect-ratio: 4/3;
      max-height: 72vh;
      margin-bottom: var(--space-3);
      --frame-color: var(--color-text);
      --grid-major: color-mix(in srgb, var(--color-accent) 30%, transparent);
      --grid-minor: color-mix(in srgb, var(--color-accent) 15%, transparent);
      --contour-color: rgba(94,247,166,0.85);
      background: var(--color-bg);
    }
    .topo-hero canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: var(--color-bg);
    }
    .topo-hero .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .topo-hero .grid {
      position: absolute;
      inset: 0;
      background-image:
        repeating-linear-gradient(var(--grid-minor) 0 1px, transparent 1px 16px),
        repeating-linear-gradient(90deg, var(--grid-minor) 0 1px, transparent 1px 16px),
        repeating-linear-gradient(var(--grid-major) 0 1px, transparent 1px 128px),
        repeating-linear-gradient(90deg, var(--grid-major) 0 1px, transparent 1px 128px);
    }
    .topo-hero .frame {
      position: absolute;
      inset: 0;
      border: 1px solid var(--frame-color);
    }
    .topo-hero .hud .coord {
      position: absolute;
      top: 4px;
      left: 4px;
      font-size: var(--text-12);
      color: color-mix(in srgb, var(--frame-color) 60%, transparent);
    }
    .topo-hero .hud .compass {
      position: absolute;
      font-size: var(--text-12);
      color: color-mix(in srgb, var(--frame-color) 60%, transparent);
    }
    .topo-hero .hud .n { top: -16px; left: 50%; transform: translateX(-50%); }
    .topo-hero .hud .s { bottom: -16px; left: 50%; transform: translateX(-50%); }
    .topo-hero .hud .e { right: -16px; top: 50%; transform: translateY(-50%); }
    .topo-hero .hud .w { left: -16px; top: 50%; transform: translateY(-50%); }
    .topo-hero .hero-text {
      position: absolute;
      bottom: var(--space-2);
      left: var(--space-2);
      color: var(--frame-color);
    }
    .topo-hero .hero-text h1 {
      margin: 0;
      font-size: var(--text-48);
    }
    .topo-hero .hero-text .subhead {
      font-size: var(--text-16);
      margin: 0;
    }
    .topo-hero .toggle {
      position: absolute;
      bottom: 4px;
      right: 4px;
      padding: 2px 6px;
      font-size: var(--text-12);
      border: 1px solid var(--frame-color);
      background: transparent;
      color: var(--frame-color);
      cursor: pointer;
    }
  </style>
  <script type="module">
    import { createNoise3D } from 'simplex-noise';
    const canvas = document.getElementById('topo-canvas');
    const ctx = canvas.getContext('2d');
    const coord = document.getElementById('coord');

    const dpr = window.devicePixelRatio || 1;
    let width, height;
    function resize() {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    const noise3D = createNoise3D();
    const baseFreq = 0.004;
    const detailFreq = 0.009;
    const detailAmp = 0.35;
    const levels = [];
    for (let l = -0.6; l <= 0.6; l += 0.15) levels.push(l);

    const cases = {
      0: [],
      1: [[3,0]],
      2: [[0,1]],
      3: [[3,1]],
      4: [[1,2]],
      5: [[3,2],[0,1]],
      6: [[0,2]],
      7: [[3,2]],
      8: [[2,3]],
      9: [[0,2]],
      10: [[1,3],[0,2]],
      11: [[1,3]],
      12: [[2,1]],
      13: [[0,1]],
      14: [[3,0]],
      15: []
    };

    function interp(a, b, t) { return a + t * (b - a); }
    function edgePos(edge, x, y, v0, v1, v2, v3, level) {
      switch(edge) {
        case 0: return [interp(x, x+1, (level - v0)/(v1 - v0)), y];
        case 1: return [x+1, interp(y, y+1, (level - v1)/(v2 - v1))];
        case 2: return [interp(x+1, x, (level - v3)/(v2 - v3)), y+1];
        case 3: return [x, interp(y+1, y, (level - v0)/(v3 - v0))];
      }
    }

    function marchingSquares(field, cols, rows, level) {
      const segs = [];
      for (let y=0;y<rows;y++) {
        for (let x=0;x<cols;x++) {
          const v0 = field[y][x];
          const v1 = field[y][x+1];
          const v2 = field[y+1][x+1];
          const v3 = field[y+1][x];
          let idx=0;
          if (v0>level) idx|=1;
          if (v1>level) idx|=2;
          if (v2>level) idx|=4;
          if (v3>level) idx|=8;
          const c = cases[idx];
          for (const pair of c) {
            const p1 = edgePos(pair[0], x, y, v0,v1,v2,v3, level);
            const p2 = edgePos(pair[1], x, y, v0,v1,v2,v3, level);
            segs.push(p1.concat(p2));
          }
        }
      }
      return segs;
    }

    const cellSize = 6;
    let cols = 0, rows = 0;
    let segsA = [], segsB = [];
    let frame = 0;
    let t = 0;

    function buildField(time, phase = 0, amp = 1) {
      const f = [];
      for (let y=0; y<=rows; y++) {
        const row = [];
        for (let x=0; x<=cols; x++) {
          const px = x * cellSize;
          const py = y * cellSize;
          const n1 = noise3D(px*baseFreq, py*baseFreq, time+phase);
          const n2 = noise3D(px*detailFreq, py*detailFreq, (time+phase)*1.3);
          row.push((n1 + n2*detailAmp) * amp);
        }
        f.push(row);
      }
      return f;
    }

    function recompute() {
      cols = Math.round(width / cellSize);
      rows = Math.round(height / cellSize);
      const fieldA = buildField(t);
      const fieldB = buildField(t + 100, 0.8, 0.8);
      segsA = levels.map(level => marchingSquares(fieldA, cols, rows, level));
      segsB = levels.map(level => marchingSquares(fieldB, cols, rows, level));
    }

    function drawSegments(segs) {
      for (const s of segs) {
        ctx.moveTo(s[0] * cellSize + 0.5, s[1] * cellSize + 0.5);
        ctx.lineTo(s[2] * cellSize + 0.5, s[3] * cellSize + 0.5);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      ctx.lineCap = ctx.lineJoin = 'round';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.85;
      ctx.strokeStyle = getComputedStyle(canvas).getPropertyValue('--contour-color');
      ctx.beginPath();
      for (const segs of segsA) drawSegments(segs);
      ctx.stroke();
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      for (const segs of segsB) drawSegments(segs);
      ctx.stroke();
      ctx.globalAlpha = 1;
      coord.textContent = `${t.toFixed(3)},0`;
    }

    let running = true;
    function loop() {
      if (!running) return;
      frame++;
      if (frame % 3 === 0) recompute();
      draw();
      t += 0.0025;
      requestAnimationFrame(loop);
    }

    const media = window.matchMedia('(prefers-reduced-motion: reduce)');
    recompute();
    if (!media.matches) {
      loop();
    } else {
      draw();
    }

    document.addEventListener('visibilitychange', () => {
      running = !document.hidden && !media.matches;
      if (running) requestAnimationFrame(loop);
    });

    const params = new URLSearchParams(location.search);
    if (params.get('debug') === '1') {
      const toggle = document.createElement('button');
      toggle.id = 'toggle';
      toggle.className = 'toggle mono';
      toggle.textContent = 'Pause';
      toggle.setAttribute('aria-pressed', 'false');
      canvas.parentElement.appendChild(toggle);
      toggle.addEventListener('click', () => {
        running = !running;
        toggle.textContent = running ? 'Pause' : 'Play';
        toggle.setAttribute('aria-pressed', (!running).toString());
        if (running) requestAnimationFrame(loop);
      });
    }
  </script>
</section>

