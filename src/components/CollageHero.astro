---
const { title } = Astro.props;

// Curated image keywords for more intentional imagery
const imageThemes = [
  'architecture',
  'satellite',
  'terrain',
  'industrial',
  'infrastructure',
  'aerial',
  'concrete',
  'geometric',
  'minimal',
  'abstract',
  'texture',
  'grid',
  'urban',
  'brutalist',
  'landscape',
  'topographic',
];
---
<section class="collage-hero">

  <!-- SVG Filter for selective color: reds pop, rest is grayscale -->
  <svg class="sr-only" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <filter id="selectiveRed" color-interpolation-filters="sRGB">
        <!-- Grayscale version -->
        <feColorMatrix type="saturate" values="0" in="SourceGraphic" result="gray"/>

        <!-- Create mask: bright where red dominates (R - avg of G,B) -->
        <feColorMatrix type="matrix" in="SourceGraphic"
          values="2 -1 -1 0 0
                  2 -1 -1 0 0
                  2 -1 -1 0 0
                  0 0 0 1 0" result="redDominance"/>

        <!-- Threshold and boost the mask -->
        <feComponentTransfer in="redDominance" result="mask">
          <feFuncR type="linear" slope="4" intercept="-0.5"/>
          <feFuncG type="linear" slope="4" intercept="-0.5"/>
          <feFuncB type="linear" slope="4" intercept="-0.5"/>
          <feFuncA type="identity"/>
        </feComponentTransfer>

        <!-- Tint the masked areas with accent red -->
        <feColorMatrix type="matrix" in="SourceGraphic"
          values="1.4 0 0 0 0.1
                  0.2 0.2 0 0 0
                  0.1 0 0.1 0 0
                  0 0 0 1 0" result="redTinted"/>

        <!-- Use mask to cut out red areas from tinted version -->
        <feComposite in="redTinted" in2="mask" operator="in" result="colorMasked"/>

        <!-- Composite colored areas over grayscale base -->
        <feBlend in="colorMasked" in2="gray" mode="normal"/>
      </filter>

      <!-- Variant: subtle warm detection - only strong reds pop -->
      <filter id="selectiveWarm" color-interpolation-filters="sRGB">
        <feColorMatrix type="saturate" values="0" in="SourceGraphic" result="gray"/>

        <!-- Strict red detection: R must strongly dominate G and B -->
        <feColorMatrix type="matrix" in="SourceGraphic"
          values="2.5 -1.2 -1.3 0 0
                  2.5 -1.2 -1.3 0 0
                  2.5 -1.2 -1.3 0 0
                  0 0 0 1 0" result="warmMask"/>

        <!-- Higher threshold = only strongest reds pass through -->
        <feComponentTransfer in="warmMask" result="mask">
          <feFuncR type="linear" slope="2" intercept="-0.6"/>
          <feFuncG type="linear" slope="2" intercept="-0.6"/>
          <feFuncB type="linear" slope="2" intercept="-0.6"/>
          <feFuncA type="identity"/>
        </feComponentTransfer>

        <!-- Subtle red tint, not overpowering -->
        <feColorMatrix type="matrix" in="SourceGraphic"
          values="1.1 0.15 0 0 0
                  0.05 0.2 0 0 0
                  0 0 0.15 0 0
                  0 0 0 1 0" result="warmShift"/>

        <feComposite in="warmShift" in2="mask" operator="in" result="colorMasked"/>
        <feBlend in="colorMasked" in2="gray" mode="normal"/>
      </filter>
    </defs>
  </svg>

  <!-- Background layer: 10 large photos covering full viewport -->
  <div class="collage-bg" id="collage-bg" style="opacity: 0; visibility: hidden;">
    {Array.from({ length: 10 }).map((_, i) => (
      <div class="collage-bg-cell" data-index={i}></div>
    ))}
  </div>

  <!-- Large foreground layer: 12 prominent images behind small -->
  <div class="collage-large" id="collage-large" style="opacity: 0; visibility: hidden;">
    {Array.from({ length: 12 }).map((_, i) => (
      <div class="collage-cell collage-cell--large" data-index={i}>
        <div class="collage-inner"></div>
      </div>
    ))}
  </div>

  <!-- Small foreground layer: 25 scattered fragments in front -->
  <div class="collage-wrap" id="collage-wrap" style="opacity: 0; visibility: hidden;">
    {Array.from({ length: 25 }).map((_, i) => (
      <div class="collage-cell collage-cell--small" data-index={i}>
        <div class="collage-inner"></div>
      </div>
    ))}
  </div>

  <!-- Top navigation bar -->
  <nav class="collage-nav" aria-label="Primary navigation">
    <a href="/" class="collage-nav__brand" data-astro-prefetch>{title}</a>
    <div class="collage-nav__links">
      <a href="/work" class="nav-link" data-astro-prefetch>
        <span class="nav-index">01</span><span class="nav-text">Work</span>
      </a>
      <a href="/blog" class="nav-link" data-astro-prefetch>
        <span class="nav-index">02</span><span class="nav-text">Blog</span>
      </a>
      <a href="/lab" class="nav-link" data-astro-prefetch>
        <span class="nav-index">03</span><span class="nav-text">Lab</span>
      </a>
      <a href="/about" class="nav-link" data-astro-prefetch>
        <span class="nav-index">04</span><span class="nav-text">About</span>
      </a>
    </div>
  </nav>

  <script type="module">
    const imageThemes = [
      'architecture', 'satellite', 'terrain', 'industrial', 'infrastructure',
      'aerial', 'concrete', 'geometric', 'minimal', 'abstract', 'texture',
      'grid', 'urban', 'brutalist', 'landscape', 'topographic', 'machinery',
      'circuit', 'blueprint', 'observatory'
    ];

    const wrap = document.getElementById('collage-wrap');
    const largeWrap = document.getElementById('collage-large');
    const bgWrap = document.getElementById('collage-bg');
    const shapesWrap = document.getElementById('collage-shapes');
    const smallCells = wrap ? wrap.querySelectorAll('.collage-cell--small') : [];
    const largeCells = largeWrap ? largeWrap.querySelectorAll('.collage-cell--large') : [];
    const bgCells = bgWrap ? bgWrap.querySelectorAll('.collage-bg-cell') : [];
    const hero = document.querySelector('.collage-hero');

    let currentSeed = Math.floor(Math.random() * 9999);

    function seededRandom(seed) {
      const x = Math.sin(seed++) * 10000;
      return x - Math.floor(x);
    }

    function draw() {
      if (!hero) return;

      // Remove ready/loaded states while we set up
      hero.classList.remove('ready');
      hero.classList.remove('loaded');

      // Hide layers during setup to prevent flash
      if (wrap) {
        wrap.style.opacity = '0';
        wrap.style.visibility = 'hidden';
      }
      if (largeWrap) {
        largeWrap.style.opacity = '0';
        largeWrap.style.visibility = 'hidden';
      }
      if (bgWrap) {
        bgWrap.style.opacity = '0';
        bgWrap.style.visibility = 'hidden';
      }

      // Clear any existing red tint shapes from previous draws
      document.querySelectorAll('.red-tint-shape').forEach(el => el.remove());

      currentSeed = Math.floor(Math.random() * 9999);
      let seed = currentSeed;

      // Track accent color shapes (5 blue mixed with mostly red)
      let blueShapesRemaining = 5;

      // Populate background layer (10 large photos covering full viewport)
      // Arranged with overlaps for complete coverage and visual depth
      const bgLayouts = [
        { x: 0, y: 0, w: 40, h: 55 },      // Top-left
        { x: 30, y: 0, w: 45, h: 50 },     // Top-center
        { x: 65, y: 0, w: 40, h: 55 },     // Top-right
        { x: 0, y: 45, w: 45, h: 60 },     // Bottom-left
        { x: 35, y: 50, w: 40, h: 55 },    // Bottom-center
        { x: 60, y: 45, w: 45, h: 60 },    // Bottom-right
        { x: 15, y: 20, w: 35, h: 45 },    // Mid-left overlay
        { x: 50, y: 25, w: 38, h: 50 },    // Mid-right overlay
        { x: 5, y: 70, w: 50, h: 35 },     // Bottom-left corner fill
        { x: 45, y: 75, w: 55, h: 30 },    // Bottom-right corner fill
      ];

      bgCells.forEach((cell, index) => {
        const layout = bgLayouts[index] || bgLayouts[0];
        cell.style.backgroundImage = 'none';
        cell.dataset.src = `https://picsum.photos/seed/${currentSeed}bg${index}/1200/1200`;

        // Position and size for full coverage (no clip-path to ensure coverage)
        cell.style.left = `${layout.x}%`;
        cell.style.top = `${layout.y}%`;
        cell.style.width = `${layout.w}%`;
        cell.style.height = `${layout.h}%`;

        // Random delay for organic assembly
        const randomDelay = seededRandom(seed + index + 8000) * 14;
        cell.style.setProperty('--bg-delay', randomDelay);
      });

      // Populate LARGE foreground layer (4 prominent images, z: 100-300)
      largeCells.forEach((cell, index) => {
        const inner = cell.querySelector('.collage-inner');
        if (!inner) return;

        // Random delay
        const randomDelay = seededRandom(seed + index + 9500) * 14;
        cell.style.setProperty('--delay', randomDelay);

        // Large fragments cover significant area (in vw units)
        const sizeVw = 35 + Math.floor(seededRandom(seed + index + 50) * 30); // 35-65vw
        const imageRes = 1000;

        // Position to cover different areas
        const posX = seededRandom(seed + index + 150) * 80 + 10; // 10-90%
        const posY = seededRandom(seed + index + 160) * 80 + 10; // 10-90%

        cell.style.left = `${posX}%`;
        cell.style.top = `${posY}%`;

        // Z-index: behind small, in front of background (100-300)
        const zIndex = 100 + Math.floor(seededRandom(seed + index + 400) * 200);

        const contrast = Math.floor(seededRandom(seed + index + 200) * 3) + 1;
        const rotate = Math.floor(seededRandom(seed + index + 300) * 8) - 4;

        // Generate torn edge clip path
        const points = [];
        const r = (base) => seededRandom(seed + index * 73 + base + 2000);
        const numPoints = 10 + Math.floor(r(1001) * 8);
        for (let p = 0; p < numPoints; p++) {
          const angle = (p / numPoints) * Math.PI * 2;
          const radius = 38 + r(1002 + p) * 15;
          const jitter = (r(1003 + p) - 0.5) * 20;
          const x = 50 + Math.cos(angle) * (radius + jitter);
          const y = 50 + Math.sin(angle) * (radius + jitter);
          points.push(`${Math.max(0, Math.min(100, x))}% ${Math.max(0, Math.min(100, y))}%`);
        }
        const clipPath = `polygon(${points.join(', ')})`;

        cell.style.setProperty('--zindex', zIndex);
        cell.style.setProperty('--rotate', `${rotate}deg`);
        inner.style.setProperty('--size-vw', `${sizeVw}vw`);
        inner.style.setProperty('--contrast', contrast);
        inner.style.setProperty('--clip', clipPath);
        inner.style.setProperty('--background', 'none');
        inner.dataset.src = `https://picsum.photos/seed/${currentSeed}lg${index}/${imageRes}/${imageRes}`;
      });

      // Populate SMALL foreground layer (50 scattered fragments, z: 400-800 - in front)
      smallCells.forEach((cell, index) => {
        const inner = cell.querySelector('.collage-inner');
        if (!inner) return;

        // Random delay
        const randomDelay = seededRandom(seed + index + 9000) * 14;
        cell.style.setProperty('--delay', randomDelay);

        // Small fragments - scattered details (in vw units)
        const sizeVw = 8 + Math.floor(seededRandom(seed + index + 50) * 18); // 8-26vw
        const imageRes = 400;

        // Random position across entire viewport
        const posX = seededRandom(seed + index + 150) * 100;
        const posY = seededRandom(seed + index + 160) * 100;

        cell.style.left = `${posX}%`;
        cell.style.top = `${posY}%`;

        // Z-index: in front of large (400-800)
        const zIndex = 400 + Math.floor(seededRandom(seed + index + 400) * 400);

        const contrast = Math.floor(seededRandom(seed + index + 200) * 3) + 1;
        const rotate = Math.floor(seededRandom(seed + index + 300) * 10) - 5;

        // Generate wildly varied ripped/torn edge clip paths
        const points = [];
        const r = (base) => seededRandom(seed + index * 73 + base);

        // Randomly choose clip style for this fragment
        const clipStyle = Math.floor(r(1000) * 8);

        if (clipStyle === 0) {
          // Heavy tear - very irregular polygon
          const numPoints = 8 + Math.floor(r(1001) * 12);
          for (let p = 0; p < numPoints; p++) {
            const angle = (p / numPoints) * Math.PI * 2;
            const radius = 35 + r(1002 + p) * 25;
            const jitter = (r(1003 + p) - 0.5) * 30;
            const x = 50 + Math.cos(angle) * (radius + jitter);
            const y = 50 + Math.sin(angle) * (radius + jitter);
            points.push(`${Math.max(0, Math.min(100, x))}% ${Math.max(0, Math.min(100, y))}%`);
          }
        } else if (clipStyle === 1) {
          // Diagonal slash
          const slant = r(1010) * 40 - 20;
          points.push(`${5 + r(1011) * 15}% ${r(1012) * 20}%`);
          points.push(`${85 + r(1013) * 15}% ${slant + r(1014) * 20}%`);
          points.push(`${90 + r(1015) * 10}% ${80 + r(1016) * 20}%`);
          points.push(`${r(1017) * 20}% ${70 + slant + r(1018) * 20}%`);
        } else if (clipStyle === 2) {
          // Torn corner
          const corner = Math.floor(r(1020) * 4);
          const tearDepth = 20 + r(1021) * 40;
          if (corner === 0) {
            points.push(`${tearDepth}% 0%`, `100% 0%`, `100% 100%`, `0% 100%`, `0% ${tearDepth}%`);
          } else if (corner === 1) {
            points.push(`0% 0%`, `${100 - tearDepth}% 0%`, `100% ${tearDepth}%`, `100% 100%`, `0% 100%`);
          } else if (corner === 2) {
            points.push(`0% 0%`, `100% 0%`, `100% ${100 - tearDepth}%`, `${100 - tearDepth}% 100%`, `0% 100%`);
          } else {
            points.push(`0% 0%`, `100% 0%`, `100% 100%`, `${tearDepth}% 100%`, `0% ${100 - tearDepth}%`);
          }
        } else if (clipStyle === 3) {
          // Jagged horizontal strip
          const y1 = 10 + r(1030) * 30;
          const y2 = 60 + r(1031) * 30;
          for (let p = 0; p <= 6; p++) {
            const x = p * 16.66;
            points.push(`${x + r(1032 + p) * 10}% ${y1 + (r(1033 + p) - 0.5) * 25}%`);
          }
          for (let p = 6; p >= 0; p--) {
            const x = p * 16.66;
            points.push(`${x + r(1040 + p) * 10}% ${y2 + (r(1041 + p) - 0.5) * 25}%`);
          }
        } else if (clipStyle === 4) {
          // Organic blob
          const numPoints = 12 + Math.floor(r(1050) * 8);
          for (let p = 0; p < numPoints; p++) {
            const angle = (p / numPoints) * Math.PI * 2;
            const wobble = Math.sin(angle * (2 + Math.floor(r(1051) * 4))) * 15;
            const radius = 30 + r(1052 + p) * 20 + wobble;
            const x = 50 + Math.cos(angle) * radius;
            const y = 50 + Math.sin(angle) * radius;
            points.push(`${x}% ${y}%`);
          }
        } else if (clipStyle === 5) {
          // Sharp triangular tear
          const apex = 20 + r(1060) * 60;
          const depth = 30 + r(1061) * 50;
          points.push(`${r(1062) * 20}% ${r(1063) * 30}%`);
          points.push(`${apex}% ${depth}%`);
          points.push(`${80 + r(1064) * 20}% ${r(1065) * 30}%`);
          points.push(`${90 + r(1066) * 10}% ${70 + r(1067) * 30}%`);
          points.push(`${r(1068) * 20}% ${80 + r(1069) * 20}%`);
        } else if (clipStyle === 6) {
          // Rough rectangle with jagged edges
          const inset = 5 + r(1070) * 15;
          const jag = () => (r(Math.random() * 10000) - 0.5) * 20;
          points.push(`${inset + jag()}% ${inset + jag()}%`);
          points.push(`${35 + jag()}% ${jag() + 5}%`);
          points.push(`${65 + jag()}% ${jag() + 5}%`);
          points.push(`${100 - inset + jag()}% ${inset + jag()}%`);
          points.push(`${95 + jag()}% ${35 + jag()}%`);
          points.push(`${95 + jag()}% ${65 + jag()}%`);
          points.push(`${100 - inset + jag()}% ${100 - inset + jag()}%`);
          points.push(`${65 + jag()}% ${95 + jag()}%`);
          points.push(`${35 + jag()}% ${95 + jag()}%`);
          points.push(`${inset + jag()}% ${100 - inset + jag()}%`);
          points.push(`${5 + jag()}% ${65 + jag()}%`);
          points.push(`${5 + jag()}% ${35 + jag()}%`);
        } else {
          // Wild random polygon
          const numPoints = 5 + Math.floor(r(1080) * 7);
          for (let p = 0; p < numPoints; p++) {
            const x = r(1081 + p * 2) * 100;
            const y = r(1082 + p * 2) * 100;
            points.push(`${x}% ${y}%`);
          }
        }

        const clipPath = `polygon(${points.join(', ')})`;

        cell.style.setProperty('--zindex', zIndex);
        cell.style.setProperty('--rotate', `${rotate}deg`);

        inner.style.setProperty('--size-vw', `${sizeVw}vw`);
        inner.style.setProperty('--contrast', contrast);
        inner.style.setProperty('--clip', clipPath);

        // Randomly add red geometric shapes to ~63% of images (10% less)
        const hasRedTint = seededRandom(seed + index + 5000) < 0.63;
        if (hasRedTint) {
          // RNG: target darks (screen) or lights (multiply)
          const targetDarks = seededRandom(seed + index + 5100) > 0.5;
          const blendMode = targetDarks ? 'screen' : 'multiply';
          const tintOpacity = 0.5 + seededRandom(seed + index + 5200) * 0.4;

          // Generate 4-12 random geometric shapes per image (doubled)
          const numShapes = 4 + Math.floor(seededRandom(seed + index + 5300) * 9);

          // Track placed shapes for collision detection
          const placedShapes = [];

          // Check if new shape overlaps with existing shapes
          const checkCollision = (x, y, w, h) => {
            for (const placed of placedShapes) {
              // Check AABB collision with padding
              const pad = 3;
              if (x < placed.x + placed.w + pad &&
                  x + w > placed.x - pad &&
                  y < placed.y + placed.h + pad &&
                  y + h > placed.y - pad) {
                return true;
              }
            }
            return false;
          };

          for (let s = 0; s < numShapes; s++) {
            const shapeType = Math.floor(seededRandom(seed + index + 5400 + s) * 9); // 9 shape types now
            // Bias towards larger sizes: invert squared random to weight towards higher values
            const sizeRoll = seededRandom(seed + index + 5450 + s);
            const biasedRoll = 1 - Math.pow(1 - sizeRoll, 2); // More values near 1
            const sizeCategory = Math.floor(biasedRoll * 4); // 0=tiny (rare), 1=small, 2=medium, 3=large (common)

            // Size multipliers based on category (10% bigger than before)
            let sizeMin, sizeMax;
            if (sizeCategory === 0) { sizeMin = 3.3; sizeMax = 13.2; }    // Tiny (+10%)
            else if (sizeCategory === 1) { sizeMin = 13.2; sizeMax = 33; } // Small (+10%)
            else if (sizeCategory === 2) { sizeMin = 33; sizeMax = 71.5; } // Medium (+10%)
            else { sizeMin = 71.5; sizeMax = 129; }                        // Large (+10%)

            const shapeW = sizeMin + seededRandom(seed + index + 5700 + s) * (sizeMax - sizeMin);
            const shapeH = sizeMin + seededRandom(seed + index + 5800 + s) * (sizeMax - sizeMin);

            // Try to find non-overlapping position (max 10 attempts)
            let shapeX, shapeY;
            let foundPosition = false;
            for (let attempt = 0; attempt < 10; attempt++) {
              shapeX = seededRandom(seed + index + 5500 + s + attempt * 100) * (90 - shapeW) + 5;
              shapeY = seededRandom(seed + index + 5600 + s + attempt * 100) * (90 - shapeH) + 5;
              if (!checkCollision(shapeX, shapeY, shapeW, shapeH)) {
                foundPosition = true;
                break;
              }
            }

            // Skip this shape if no valid position found
            if (!foundPosition) continue;

            // Record placed shape for collision detection
            placedShapes.push({ x: shapeX, y: shapeY, w: shapeW, h: shapeH });

            const rotation = (seededRandom(seed + index + 5900 + s) - 0.5) * 60;
            let shapeStyle = '';

            if (shapeType === 0) {
              // Horizontal strip
              const stripH = sizeCategory === 0 ? 2 + seededRandom(seed + index + 6000 + s) * 4 :
                            sizeCategory === 1 ? 4 + seededRandom(seed + index + 6000 + s) * 8 :
                            sizeCategory === 2 ? 8 + seededRandom(seed + index + 6000 + s) * 15 :
                            18 + seededRandom(seed + index + 6000 + s) * 30;
              shapeStyle = `width: ${shapeW}%; height: ${stripH}%;`;
            } else if (shapeType === 1) {
              // Vertical strip
              const stripW = sizeCategory === 0 ? 2 + seededRandom(seed + index + 6000 + s) * 4 :
                            sizeCategory === 1 ? 4 + seededRandom(seed + index + 6000 + s) * 8 :
                            sizeCategory === 2 ? 8 + seededRandom(seed + index + 6000 + s) * 15 :
                            18 + seededRandom(seed + index + 6000 + s) * 30;
              shapeStyle = `width: ${stripW}%; height: ${shapeH}%;`;
            } else if (shapeType === 2) {
              // Square block
              const blockSize = sizeMin + seededRandom(seed + index + 6000 + s) * (sizeMax - sizeMin);
              shapeStyle = `width: ${blockSize}%; height: ${blockSize}%;`;
            } else if (shapeType === 3) {
              // Rectangle block
              shapeStyle = `width: ${shapeW}%; height: ${shapeH}%;`;
            } else if (shapeType === 4) {
              // Thin line
              const lineThick = sizeCategory === 0 ? 1 + seededRandom(seed + index + 6100 + s) * 2 :
                               sizeCategory === 1 ? 2 + seededRandom(seed + index + 6100 + s) * 4 :
                               3 + seededRandom(seed + index + 6100 + s) * 8;
              shapeStyle = `width: ${shapeW}%; height: ${lineThick}%;`;
            } else if (shapeType === 5) {
              // Diagonal slash (parallelogram)
              const slashW = shapeW * 0.3;
              shapeStyle = `width: ${slashW}%; height: ${shapeH}%; transform: skewX(${20 + seededRandom(seed + index + 6200 + s) * 25}deg) rotate(${rotation}deg);`;
            } else if (shapeType === 6) {
              // L-shaped block (clip-path)
              const lSize = sizeMin + seededRandom(seed + index + 6300 + s) * (sizeMax - sizeMin) * 0.8;
              shapeStyle = `width: ${lSize}%; height: ${lSize}%; clip-path: polygon(0% 0%, 50% 0%, 50% 50%, 100% 50%, 100% 100%, 0% 100%);`;
            } else if (shapeType === 7) {
              // Cross/plus shape
              const crossSize = sizeMin + seededRandom(seed + index + 6400 + s) * (sizeMax - sizeMin) * 0.7;
              shapeStyle = `width: ${crossSize}%; height: ${crossSize}%; clip-path: polygon(33% 0%, 66% 0%, 66% 33%, 100% 33%, 100% 66%, 66% 66%, 66% 100%, 33% 100%, 33% 66%, 0% 66%, 0% 33%, 33% 33%);`;
            } else {
              // Trapezoid
              const trapW = shapeW;
              const trapH = shapeH * 0.6;
              const skew = 10 + seededRandom(seed + index + 6500 + s) * 20;
              shapeStyle = `width: ${trapW}%; height: ${trapH}%; clip-path: polygon(${skew}% 0%, ${100-skew}% 0%, 100% 100%, 0% 100%);`;
            }

            // Create overlay as SIBLING to inner (outside grayscale filter)
            const tintOverlay = document.createElement('div');
            tintOverlay.className = 'red-tint-shape';
            // Use same random delay as parent cell image
            const shapeDelay = seededRandom(seed + index + 9000) * 14 * 0.2; // Same as cell --delay

            // Individual shape opacity variance: 0.05 to 0.7 for subtler range
            const shapeOpacity = 0.05 + seededRandom(seed + index + 7000 + s) * 0.65;

            // Convert percentage positions to vw units relative to image size
            const shapeLeftVw = (shapeX / 100 - 0.5) * sizeVw;
            const shapeTopVw = (shapeY / 100 - 0.5) * sizeVw;
            const shapeWVw = (shapeW / 100) * sizeVw;
            const shapeHVw = (shapeH / 100) * sizeVw;

            // Pick shape color - mostly red, with 10 blue randomly
            let shapeColor = '#8b2635'; // Default red
            const colorRoll = seededRandom(seed + index + 7500 + s);
            if (blueShapesRemaining > 0 && colorRoll < 0.15) {
              shapeColor = '#2d5a7b'; // Muted steel blue
              blueShapesRemaining--;
            }

            // For shapes with custom transform, don't add rotation again
            const hasCustomTransform = shapeType === 5;
            tintOverlay.style.cssText = `
              position: absolute;
              left: ${shapeLeftVw}vw;
              top: ${shapeTopVw}vw;
              width: ${shapeWVw}vw;
              height: ${shapeHVw}vw;
              background: ${shapeColor};
              ${!hasCustomTransform ? `transform: rotate(${rotation}deg);` : ''}
              mix-blend-mode: ${blendMode};
              pointer-events: none;
              z-index: 10;
              opacity: 0;
              transition: opacity 0.6s cubic-bezier(0.25, 0.1, 0.25, 1);
              transition-delay: ${shapeDelay}s;
            `;
            // Store target opacity for JS animation (now per-shape variance)
            tintOverlay.dataset.targetOpacity = shapeOpacity;
            cell.appendChild(tintOverlay);
          }
        }

        // Lazy load images - resolution matches fragment size
        inner.style.setProperty('--background', 'none');
        inner.dataset.src = `https://picsum.photos/seed/${currentSeed}${index}/${imageRes}/${imageRes}`;
      });

      // Lazy load visible images
      lazyLoadImages();

      // First make layout visible (but individual elements still at opacity 0)
      requestAnimationFrame(() => {
        // Remove inline hiding styles and let CSS take over
        if (wrap) {
          wrap.style.opacity = '1';
          wrap.style.visibility = 'visible';
        }
        if (largeWrap) {
          largeWrap.style.opacity = '1';
          largeWrap.style.visibility = 'visible';
        }
        if (bgWrap) {
          bgWrap.style.opacity = '1';
          bgWrap.style.visibility = 'visible';
        }
        hero.classList.add('ready');

        // Then trigger the fade-in animation after a frame
        requestAnimationFrame(() => {
          hero.classList.add('loaded');

          // Trigger red shapes to fade in (they have inline transition-delay)
          document.querySelectorAll('.red-tint-shape').forEach(shape => {
            const targetOpacity = shape.dataset.targetOpacity || 0.7;
            shape.style.opacity = targetOpacity;
          });
        });
      });
    }

    function lazyLoadImages() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const el = entry.target;
            const src = el.dataset.src;
            if (src) {
              // Check if it's a background cell or foreground inner
              if (el.classList.contains('collage-bg-cell')) {
                el.style.backgroundImage = `url(${src})`;
              } else {
                el.style.setProperty('--background', `url(${src})`);
              }
              delete el.dataset.src;
            }
            observer.unobserve(el);
          }
        });
      }, { rootMargin: '50px' });

      // Observe background cells
      bgCells.forEach(cell => {
        if (cell.dataset.src) {
          observer.observe(cell);
        }
      });

      // Observe large foreground cells
      largeCells.forEach(cell => {
        const inner = cell.querySelector('.collage-inner');
        if (inner && inner.dataset.src) {
          observer.observe(inner);
        }
      });

      // Observe small foreground cells
      smallCells.forEach(cell => {
        const inner = cell.querySelector('.collage-inner');
        if (inner && inner.dataset.src) {
          observer.observe(inner);
        }
      });
    }

    // Generate random geometric shapes overlay
    // Shapes are clipped to individual cells and use blend modes to emerge from darks/lights
    function generateShapes() {
      if (!shapesWrap) return;
      shapesWrap.innerHTML = '';

      const r = (offset) => seededRandom(currentSeed + offset);
      const cellSize = 12.5; // 100/8 = 12.5% per cell

      // Generate 25-45 shapes
      const numShapes = 25 + Math.floor(r(5000) * 20);

      // Track which cells have shapes
      const usedCells = new Set();

      for (let i = 0; i < numShapes; i++) {
        // Pick a random cell - each shape locked to ONE cell
        let targetCell;
        let attempts = 0;
        do {
          targetCell = Math.floor(r(6000 + i * 100 + attempts) * 64);
          attempts++;
        } while (usedCells.has(targetCell) && attempts < 8);

        // 60% chance to claim the cell (some overlap allowed)
        if (r(7000 + i) > 0.4) {
          usedCells.add(targetCell);
        }

        const cellCol = targetCell % 8;
        const cellRow = Math.floor(targetCell / 8);

        // Cell bounds
        const cellLeft = cellCol * cellSize;
        const cellTop = cellRow * cellSize;

        // Position WITHIN the cell bounds
        const offsetX = r(8000 + i) * cellSize * 0.6;
        const offsetY = r(8100 + i) * cellSize * 0.6;

        // Size - constrained to not exceed cell too much
        const sizeType = Math.floor(r(8200 + i) * 4);
        let width, height;
        if (sizeType === 0) {
          width = 2 + r(8300 + i) * 4;
          height = 2 + r(8301 + i) * 4;
        } else if (sizeType === 1) {
          width = 4 + r(8300 + i) * 6;
          height = 4 + r(8301 + i) * 6;
        } else if (sizeType === 2) {
          width = 6 + r(8300 + i) * 8;
          height = 6 + r(8301 + i) * 8;
        } else {
          width = 8 + r(8300 + i) * 10;
          height = 8 + r(8301 + i) * 10;
        }

        // Shape type
        const shapeType = Math.floor(r(9000 + i) * 10);
        let shapeClip = '';
        let borderRadius = '0';

        switch (shapeType) {
          case 0: borderRadius = '50%'; break;
          case 1: borderRadius = '50%'; height = width * (0.4 + r(9100 + i) * 0.5); break;
          case 2: shapeClip = 'polygon(50% 0%, 100% 100%, 0% 100%)'; break;
          case 3: shapeClip = 'polygon(0% 0%, 100% 0%, 50% 100%)'; break;
          case 4: shapeClip = 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)'; break;
          case 5: shapeClip = 'polygon(20% 0%, 100% 0%, 80% 100%, 0% 100%)'; break;
          case 6: height = 0.8 + r(9400 + i) * 1.5; width = 6 + r(9401 + i) * 10; break;
          case 7: width = 0.8 + r(9400 + i) * 1.5; height = 6 + r(9401 + i) * 10; break;
          case 8: shapeClip = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)'; break;
          default: break;
        }

        // Rotation
        const rotation = Math.floor(r(9500 + i) * 90) - 45;

        // RNG: target darks (screen) or lights (multiply)
        const targetDarks = r(9550 + i) > 0.5;
        const blendMode = targetDarks ? 'screen' : 'multiply';

        // Opacity varies based on blend mode
        let opacity;
        if (targetDarks) {
          // Screen mode - needs higher opacity to be visible
          opacity = 0.5 + r(9700 + i) * 0.4;
        } else {
          // Multiply mode - can be more subtle
          opacity = 0.3 + r(9700 + i) * 0.5;
        }

        const shape = document.createElement('div');
        shape.style.cssText = `
          position: absolute;
          left: ${cellLeft + offsetX}%;
          top: ${cellTop + offsetY}%;
          width: ${width}%;
          height: ${height}%;
          background: #8b2635;
          transform: rotate(${rotation}deg);
          opacity: ${opacity};
          mix-blend-mode: ${blendMode};
          ${shapeClip ? `clip-path: ${shapeClip};` : ''}
          ${borderRadius !== '0' ? `border-radius: ${borderRadius};` : ''}
        `;

        shapesWrap.appendChild(shape);
      }
    }

    // Scroll-based nav behavior
    function setupNav() {
      const nav = document.querySelector('.collage-nav');
      if (!nav || !hero) return;

      const setNavHeight = () => {
        hero.style.setProperty('--nav-height', `${nav.offsetHeight}px`);
      };

      const onScroll = () => {
        const navHeight = nav.offsetHeight;
        if (window.scrollY > hero.offsetHeight - navHeight) {
          hero.classList.add('collapsed');
          nav.classList.add('sticky');
        } else {
          hero.classList.remove('collapsed');
          nav.classList.remove('sticky');
        }
      };

      setNavHeight();
      onScroll();

      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', () => {
        setNavHeight();
        onScroll();
      });
    }

    // Initialize
    draw();
    setupNav();
  </script>

  <style>
    .collage-hero {
      position: relative;
      width: 100%;
      height: 100vh;
      height: 100svh;
      background: var(--color-bg);
      perspective: 800px;
      overflow: hidden;
      --nav-height: 64px;
    }


    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
    }

    /* ===== BACKGROUND LAYER: 6 large photos for full coverage ===== */
    .collage-bg {
      position: absolute;
      inset: 0;
      z-index: 1;
      /* Hidden by default until JS adds .ready */
      opacity: 0;
      visibility: hidden;
    }

    .collage-hero.ready .collage-bg {
      opacity: 1;
      visibility: visible;
    }

    .collage-bg-cell {
      position: absolute;
      background-size: cover;
      background-position: center;
      filter: grayscale(100%) contrast(1.2);
      opacity: 0;
      transition: opacity 0.8s cubic-bezier(0.25, 0.1, 0.25, 1);
    }

    /* Background cells fade in to low opacity when loaded */
    .collage-hero.loaded .collage-bg-cell {
      opacity: 0.4;
    }

    /* ===== LARGE FOREGROUND LAYER: Behind small, in front of background ===== */
    .collage-large {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
      pointer-events: none;
      z-index: 2;
      opacity: 0;
      visibility: hidden;
    }

    .collage-hero.ready .collage-large {
      opacity: 1;
      visibility: visible;
    }

    /* ===== SMALL FOREGROUND LAYER: In front of everything ===== */
    .collage-wrap {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
      pointer-events: none;
      z-index: 3;
      /* Hidden by default until JS adds .ready */
      opacity: 0;
      visibility: hidden;
    }

    .collage-hero.ready .collage-wrap {
      opacity: 1;
      visibility: visible;
    }

    .collage-cell {
      position: absolute;
      transform-style: preserve-3d;
      z-index: var(--zindex, 500);
      transform: rotate(var(--rotate, 0deg));
    }

    .collage-inner {
      position: absolute;
      left: 0;
      top: 0;
      transform: translate(-50%, -50%);
      /* Use viewport units since parent has no intrinsic size */
      width: var(--size-vw, 20vw);
      height: var(--size-vw, 20vw);
      background-image: var(--background, none);
      background-size: cover;
      background-position: center;
      /* Ripped edge on the image */
      clip-path: var(--clip, polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%));
      /* High contrast grayscale base */
      filter: grayscale(100%) contrast(var(--contrast, 1.2));
      opacity: 0;
      /* Pop in with staggered random delays */
      transition: opacity 0.6s cubic-bezier(0.25, 0.1, 0.25, 1);
    }

    /* Red tint shapes - styling only, animation controlled by JS */
    .red-tint-shape {
      /* Styles set via inline JS for proper timing sync */
    }

    /* ===== RED GEOMETRIC OVERLAY LAYER ===== */
    /* Uses fixed position to escape 3D stacking context from perspective/transform-style */
    .collage-shapes {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      height: 100svh;
      z-index: 100;
      pointer-events: none;
      mix-blend-mode: multiply;
    }

    .collage-shape {
      position: absolute;
      background-color: #8b2635;
    }

    /* Staggered loading animation - pop in with opacity only */
    .collage-hero.loaded .collage-cell .collage-inner,
    .collage-hero.loaded .collage-large .collage-cell .collage-inner {
      opacity: 1;
    }

    /* Random delays - each cell gets independent timing for organic assembly */
    .collage-hero.loaded .collage-cell .collage-inner,
    .collage-hero.loaded .collage-large .collage-cell .collage-inner {
      /* Random delay 0-2.8s, set via JS --delay variable */
      transition-delay: calc(var(--delay, 0) * 0.2s);
    }
    /* Red shapes get their delay via inline styles in JS for proper sync */

    /* Background cells also get random delays */
    .collage-hero.loaded .collage-bg-cell {
      transition-delay: calc(var(--bg-delay, 0) * 0.2s);
    }

    /* Delays are now set via JS inline styles for random timing */


    /* ===== TOP NAVIGATION ===== */
    .collage-nav {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      padding: var(--space-3) var(--space-5);
      z-index: 9999;
      pointer-events: auto;
      background: var(--color-bg);
      border-bottom: 1px solid var(--border-faint);
    }

    .collage-nav__brand {
      font-family: var(--font-sans);
      font-size: var(--text-12);
      font-weight: 600;
      letter-spacing: 0.35em;
      text-transform: uppercase;
      color: var(--color-text);
      text-decoration: none;
      border-bottom: none;
    }

    .collage-nav__brand:hover {
      color: var(--color-text);
    }

    .collage-nav__links {
      display: flex;
      gap: var(--space-5);
    }

    .collage-nav__links a {
      font-family: var(--font-mono);
      font-size: var(--text-10);
      font-weight: 400;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--color-text);
      text-decoration: none;
      border-bottom: none;
      display: flex;
      align-items: baseline;
      gap: 0.5em;
      transition: color 0.2s ease;
      position: relative;
      overflow: visible;
    }

    .nav-index {
      font-size: var(--text-8);
      color: var(--text-alpha-35);
      font-weight: 400;
      letter-spacing: 0.02em;
      transition: color 0.2s ease;
    }

    .collage-nav__links a:hover {
      color: var(--color-accent);
    }

    .collage-nav__links a:hover .nav-index {
      color: var(--color-accent);
    }

    .collage-nav__links a:focus-visible {
      outline: 1px solid var(--color-accent);
      outline-offset: 4px;
    }

    /* Sticky nav state */
    .collage-nav.sticky {
      position: fixed;
      background: var(--color-bg);
      padding: var(--space-3) var(--space-6);
    }

    .collage-hero.collapsed {
      height: var(--nav-height);
      max-height: var(--nav-height);
    }

    /* Mobile adjustments */
    @media (max-width: 640px) {
      .collage-nav {
        padding: var(--space-3) var(--space-4);
      }

      .collage-nav__brand {
        font-size: var(--text-10);
        letter-spacing: 0.2em;
      }

      .collage-nav__links {
        gap: 0;
      }

      .collage-nav__links a {
        font-size: var(--text-9);
        padding: 0 var(--space-2);
        border-left: 1px solid var(--border-faint);
      }

      .collage-nav__links a:first-child {
        border-left: none;
        padding-left: 0;
      }

      .nav-index {
        display: none;
      }

      .collage-nav.sticky {
        padding: var(--space-2) var(--space-4);
      }

      .collage-nav.sticky .collage-nav__links {
        display: none;
      }
    }

    /* Tablet - show arm but adjust positioning */
    @media (min-width: 641px) and (max-width: 900px) {
      .collage-nav {
        padding: var(--space-3) var(--space-4);
      }

      .collage-nav__links {
        gap: var(--space-4);
      }

      .collage-nav__links a {
        font-size: var(--text-9);
      }
    }

    /* Dark theme adjustments */
    .theme-dark .collage-inner {
      filter: grayscale(100%) contrast(var(--contrast, 1.2)) invert(1);
    }

    .theme-dark .collage-bg-cell {
      filter: grayscale(100%) contrast(1.2) invert(1);
    }

    .theme-dark .collage-shapes {
      mix-blend-mode: screen;
    }

    .theme-dark .collage-nav {
      background: var(--color-bg);
    }
  </style>
</section>
