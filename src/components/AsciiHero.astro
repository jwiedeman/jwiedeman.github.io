---
interface Props {
  title?: string;
  dataUrl?: string;
}

const { title = 'JWIEDEMAN', dataUrl = '/lava-ascii.json' } = Astro.props;
---

<section class="ascii-hero" data-ascii-hero data-url={dataUrl}>
  <canvas class="ascii-hero__canvas" data-ascii-canvas></canvas>

  <!-- Navigation -->
  <nav class="ascii-hero__nav" aria-label="Primary navigation">
    <a href="/" class="ascii-hero__brand" data-astro-prefetch>
      <span class="ascii-hero__brand-j">J</span><span class="ascii-hero__brand-rest">WIEDEMAN</span>
    </a>
    <div class="ascii-hero__links">
      <a href="/work" class="nav-link" data-astro-prefetch>
        <span class="nav-index">01</span><span class="nav-text">Work</span>
      </a>
      <a href="/blog" class="nav-link" data-astro-prefetch>
        <span class="nav-index">02</span><span class="nav-text">Blog</span>
      </a>
      <a href="/lab" class="nav-link" data-astro-prefetch>
        <span class="nav-index">03</span><span class="nav-text">Lab</span>
      </a>
      <a href="/about" class="nav-link" data-astro-prefetch>
        <span class="nav-index">04</span><span class="nav-text">About</span>
      </a>
    </div>
  </nav>
</section>

<style>
  .ascii-hero {
    position: relative;
    width: 100%;
    height: 100vh;
    height: 100svh;
    background: var(--color-bg, #0a0a0a);
    overflow: hidden;
  }

  .ascii-hero__canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  /* Navigation */
  .ascii-hero__nav {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    padding: var(--space-3) var(--space-5);
    z-index: 100;
    background: var(--bg-alpha-90, rgba(10, 10, 10, 0.9));
    backdrop-filter: blur(8px);
    border-bottom: 1px solid var(--border-faint, rgba(255, 255, 255, 0.1));
  }

  .ascii-hero__brand {
    font-family: var(--font-sans);
    font-size: var(--text-14);
    font-weight: 700;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: var(--color-text, #d9d4cc);
    text-decoration: none;
    border-bottom: none;
    display: flex;
    align-items: baseline;
  }

  .ascii-hero__brand-j {
    color: var(--color-accent, #ff6b35);
    font-weight: 800;
    margin-right: -0.05em;
  }

  .ascii-hero__brand-rest {
    color: var(--color-text, #d9d4cc);
  }

  .ascii-hero__brand:hover .ascii-hero__brand-rest {
    color: var(--color-accent, #ff6b35);
  }

  .ascii-hero__links {
    display: flex;
    gap: var(--space-5);
  }

  .ascii-hero__links a {
    font-family: var(--font-mono);
    font-size: var(--text-12);
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--color-text, #d9d4cc);
    text-decoration: none;
    border-bottom: none;
    display: flex;
    align-items: baseline;
    gap: 0.5em;
    transition: color 0.2s ease;
  }

  .ascii-hero__links .nav-index {
    font-size: var(--text-10);
    color: var(--text-alpha-35, rgba(217, 212, 204, 0.35));
    font-weight: 500;
    letter-spacing: 0.02em;
    transition: color 0.2s ease;
  }

  .ascii-hero__links a:hover {
    color: var(--color-accent, #ff6b35);
  }

  .ascii-hero__links a:hover .nav-index {
    color: var(--color-accent, #ff6b35);
  }

  /* Mobile adjustments */
  @media (max-width: 640px) {
    .ascii-hero__nav {
      padding: var(--space-3) var(--space-4);
    }

    .ascii-hero__brand {
      font-size: var(--text-11);
      letter-spacing: 0.2em;
    }

    .ascii-hero__links {
      gap: 0;
    }

    .ascii-hero__links a {
      font-size: var(--text-10);
      font-weight: 600;
      padding: 0 var(--space-2);
      border-left: 1px solid var(--border-faint, rgba(255, 255, 255, 0.1));
    }

    .ascii-hero__links a:first-child {
      border-left: none;
      padding-left: 0;
    }

    .ascii-hero__links .nav-index {
      display: none;
    }
  }
</style>

<script>
  interface AsciiData {
    w: number;
    h: number;
    fps: number;
    chars: string;
    frames: string[][];
  }

  class AsciiRenderer {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private data: AsciiData | null = null;
    private currentFrame = 0;
    private animationId: number | null = null;
    private lastFrameTime = 0;
    private frameInterval = 1000 / 12;

    // Lava color gradient: black -> dark red -> red -> orange -> yellow -> white
    private colorStops = [
      { pos: 0.0, r: 10, g: 10, b: 10 },      // Near black
      { pos: 0.15, r: 40, g: 10, b: 5 },      // Very dark red
      { pos: 0.3, r: 120, g: 20, b: 10 },     // Dark red
      { pos: 0.45, r: 180, g: 50, b: 10 },    // Red
      { pos: 0.6, r: 220, g: 100, b: 20 },    // Orange-red
      { pos: 0.75, r: 250, g: 150, b: 30 },   // Orange
      { pos: 0.85, r: 255, g: 200, b: 80 },   // Yellow-orange
      { pos: 0.95, r: 255, g: 240, b: 180 },  // Pale yellow
      { pos: 1.0, r: 255, g: 255, b: 240 },   // Near white
    ];

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('Could not get 2d context');
      this.ctx = ctx;
    }

    private getColorForBrightness(brightness: number): string {
      // Find the two color stops to interpolate between
      let lower = this.colorStops[0];
      let upper = this.colorStops[this.colorStops.length - 1];

      for (let i = 0; i < this.colorStops.length - 1; i++) {
        if (brightness >= this.colorStops[i].pos && brightness <= this.colorStops[i + 1].pos) {
          lower = this.colorStops[i];
          upper = this.colorStops[i + 1];
          break;
        }
      }

      // Interpolate
      const range = upper.pos - lower.pos;
      const t = range > 0 ? (brightness - lower.pos) / range : 0;

      const r = Math.round(lower.r + (upper.r - lower.r) * t);
      const g = Math.round(lower.g + (upper.g - lower.g) * t);
      const b = Math.round(lower.b + (upper.b - lower.b) * t);

      return `rgb(${r},${g},${b})`;
    }

    async load(url: string): Promise<void> {
      const response = await fetch(url);
      this.data = await response.json();
      this.frameInterval = 1000 / (this.data?.fps || 12);
      this.resize();
    }

    resize(): void {
      if (!this.data) return;

      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();

      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;

      this.ctx.scale(dpr, dpr);
    }

    private renderFrame(): void {
      if (!this.data) return;

      const rect = this.canvas.getBoundingClientRect();
      const { w, h, chars, frames } = this.data;
      const frame = frames[this.currentFrame];

      // Clear canvas
      this.ctx.fillStyle = '#0a0a0a';
      this.ctx.fillRect(0, 0, rect.width, rect.height);

      // Calculate character size to fill the canvas
      const charWidth = rect.width / w;
      const charHeight = rect.height / h;
      const fontSize = Math.min(charWidth * 1.8, charHeight * 0.95);

      this.ctx.font = `${fontSize}px "JetBrains Mono", "Fira Code", monospace`;
      this.ctx.textBaseline = 'top';

      // Render each character
      for (let y = 0; y < h && y < frame.length; y++) {
        const row = frame[y];
        for (let x = 0; x < w && x < row.length; x++) {
          const char = row[x];
          if (char === ' ') continue;

          // Calculate brightness from character position in the charset
          const charIndex = chars.indexOf(char);
          const brightness = charIndex >= 0 ? charIndex / (chars.length - 1) : 0;

          if (brightness < 0.02) continue; // Skip very dark characters

          this.ctx.fillStyle = this.getColorForBrightness(brightness);
          this.ctx.fillText(char, x * charWidth, y * charHeight);
        }
      }
    }

    private animate = (timestamp: number): void => {
      if (!this.data) return;

      if (timestamp - this.lastFrameTime >= this.frameInterval) {
        this.renderFrame();
        this.currentFrame = (this.currentFrame + 1) % this.data.frames.length;
        this.lastFrameTime = timestamp;
      }

      this.animationId = requestAnimationFrame(this.animate);
    };

    start(): void {
      if (this.animationId) return;
      this.lastFrameTime = performance.now();
      this.animationId = requestAnimationFrame(this.animate);
    }

    stop(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }
  }

  // Initialize all ASCII heroes on the page
  function initAsciiHeroes(): void {
    const heroes = document.querySelectorAll('[data-ascii-hero]');

    heroes.forEach((hero) => {
      const canvas = hero.querySelector('[data-ascii-canvas]') as HTMLCanvasElement | null;
      const url = (hero as HTMLElement).dataset.url || '/lava-ascii.json';

      if (!canvas) return;

      const renderer = new AsciiRenderer(canvas);

      renderer.load(url).then(() => {
        renderer.start();
      }).catch((err) => {
        console.error('Failed to load ASCII animation:', err);
      });

      // Handle resize
      let resizeTimeout: ReturnType<typeof setTimeout>;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => renderer.resize(), 100);
      });

      // Pause when not visible
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            renderer.start();
          } else {
            renderer.stop();
          }
        });
      });

      observer.observe(hero);
    });
  }

  // Run on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAsciiHeroes);
  } else {
    initAsciiHeroes();
  }
</script>
